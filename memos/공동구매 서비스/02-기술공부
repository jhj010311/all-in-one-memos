2. ì½”ë“œë¡œ ë³´ëŠ” ê³¼ì •
ì„œë²„ ì¸¡ (Spring Boot)
java
@RestController
public class NotificationController {

    // ì‚¬ìš©ìë³„ ì—°ê²°ì„ ì €ì¥í•˜ëŠ” Map
    private final Map<String, SseEmitter> connections = new ConcurrentHashMap<>();

    @GetMapping(value = "/notifications/stream",
                produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public SseEmitter subscribe(@RequestParam String userId) {

        // 1. ìƒˆë¡œìš´ SSE ì—°ê²° ìƒì„± (30ë¶„ íƒ€ì„ì•„ì›ƒ)
        SseEmitter emitter = new SseEmitter(30 * 60 * 1000L);

        // 2. ì‚¬ìš©ìë³„ ì—°ê²° ì €ì¥
        connections.put(userId, emitter);

        // 3. ì—°ê²° ì¢…ë£Œ ì‹œ ì •ë¦¬ ì‘ì—…
        emitter.onCompletion(() -> {
            connections.remove(userId);
            System.out.println("ì—°ê²° ì™„ë£Œ: " + userId);
        });

        emitter.onTimeout(() -> {
            connections.remove(userId);
            System.out.println("ì—°ê²° íƒ€ì„ì•„ì›ƒ: " + userId);
        });

        emitter.onError((ex) -> {
            connections.remove(userId);
            System.out.println("ì—°ê²° ì˜¤ë¥˜: " + userId);
        });

        // 4. ì´ˆê¸° ì—°ê²° í™•ì¸ ë©”ì‹œì§€ ì „ì†¡
        try {
            emitter.send(SseEmitter.event()
                .name("connect")
                .data("ì—°ê²°ë˜ì—ˆìŠµë‹ˆë‹¤"));
        } catch (IOException e) {
            connections.remove(userId);
        }

        return emitter;
    }

    // íŠ¹ì • ì‚¬ìš©ìì—ê²Œ ì•Œë¦¼ ì „ì†¡
    public void sendNotification(String userId, Object data) {
        SseEmitter emitter = connections.get(userId);
        if (emitter != null) {
            try {
                emitter.send(SseEmitter.event()
                    .name("notification")
                    .data(data));
            } catch (IOException e) {
                // ì „ì†¡ ì‹¤íŒ¨ ì‹œ ì—°ê²° ì œê±°
                connections.remove(userId);
            }
        }
    }
}
í´ë¼ì´ì–¸íŠ¸ ì¸¡ (JavaScript)
javascript// 1. SSE ì—°ê²° ìƒì„±
const eventSource = new EventSource('/notifications/stream?userId=user123');

// 2. ì—°ê²° ì„±ê³µ ì‹œ
eventSource.onopen = function(event) {
    console.log('SSE ì—°ê²°ë¨');
};

// 3. ë©”ì‹œì§€ ìˆ˜ì‹  ì‹œ
eventSource.onmessage = function(event) {
    const data = JSON.parse(event.data);
    console.log('ì•Œë¦¼ ë°›ìŒ:', data);

    // ì•Œë¦¼ì„ í™”ë©´ì— í‘œì‹œ
    showNotification(data);
};

// 4. íŠ¹ì • ì´ë²¤íŠ¸ íƒ€ì… ì²˜ë¦¬
eventSource.addEventListener('notification', function(event) {
    const notification = JSON.parse(event.data);
    displayNotificationModal(notification);
});

// 5. ì—°ê²° ì˜¤ë¥˜ ì‹œ (ìë™ ì¬ì—°ê²°ë¨)
eventSource.onerror = function(event) {
    console.log('SSE ì—°ê²° ì˜¤ë¥˜');
};

// 6. ì—°ê²° ì¢…ë£Œ
function closeConnection() {
    eventSource.close();
}
ì—°ê²° ê´€ë¦¬ê°€ í•„ìš”í•œ ì´ìœ 
1. ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€
java// ë¬¸ì œ: ì‚¬ìš©ìê°€ ë¸Œë¼ìš°ì €ë¥¼ ë‹«ì•„ë„ ì„œë²„ì—ëŠ” ì—°ê²° ì •ë³´ê°€ ë‚¨ì•„ìˆìŒ
Map<String, SseEmitter> connections = new HashMap<>();

// í•´ê²°: ì •ê¸°ì ìœ¼ë¡œ ë¹„í™œì„± ì—°ê²° ì •ë¦¬
@Scheduled(fixedRate = 60000) // 1ë¶„ë§ˆë‹¤ ì‹¤í–‰
public void cleanupInactiveConnections() {
    connections.entrySet().removeIf(entry -> {
        SseEmitter emitter = entry.getValue();
        try {
            // ì—°ê²° ìƒíƒœ í™•ì¸ìš© heartbeat ì „ì†¡
            emitter.send(SseEmitter.event().name("heartbeat").data("ping"));
            return false; // ì „ì†¡ ì„±ê³µí•˜ë©´ ìœ ì§€
        } catch (IOException e) {
            // ì „ì†¡ ì‹¤íŒ¨í•˜ë©´ ì—°ê²°ì´ ëŠì–´ì§„ ê²ƒìœ¼ë¡œ íŒë‹¨
            return true; // ëª©ë¡ì—ì„œ ì œê±°
        }
    });
}
2. ì‹¤ì œ ì—°ê²° ìƒíƒœ vs ì €ì¥ëœ ì—°ê²° ì •ë³´ ë¶ˆì¼ì¹˜
ì‹œë‚˜ë¦¬ì˜¤:
1. ì‚¬ìš©ìê°€ ë¸Œë¼ìš°ì €ë¡œ SSE ì—°ê²°
2. ì„œë²„ì˜ connections Mapì— ì—°ê²° ì •ë³´ ì €ì¥
3. ì‚¬ìš©ìê°€ ê°‘ìê¸° ë¸Œë¼ìš°ì € ì¢…ë£Œ (ì •ìƒì ì¸ disconnect ì—†ì´)
4. ì„œë²„ëŠ” ì—¬ì „íˆ ì—°ê²°ì´ ì‚´ì•„ìˆë‹¤ê³  ìƒê°
5. ì•Œë¦¼ ì „ì†¡ ì‹œ IOException ë°œìƒ

í•´ê²°ì±…: ì˜¤ë¥˜ ë°œìƒ ì‹œ ì¦‰ì‹œ ì—°ê²° ì •ë³´ ì •ë¦¬
3. í™•ì¥ëœ ì—°ê²° ê´€ë¦¬ ì˜ˆì‹œ
java@Component
public class SseConnectionManager {

    private final Map<String, SseConnection> connections = new ConcurrentHashMap<>();

    public static class SseConnection {
        private final SseEmitter emitter;
        private final LocalDateTime lastActivity;
        private final String sessionId;

        // ìƒì„±ì, getter ë“±...
    }

    public SseEmitter createConnection(String userId) {
        // ê¸°ì¡´ ì—°ê²°ì´ ìˆë‹¤ë©´ ì¢…ë£Œ
        closeExistingConnection(userId);

        SseEmitter emitter = new SseEmitter(30 * 60 * 1000L);
        String sessionId = UUID.randomUUID().toString();

        SseConnection connection = new SseConnection(emitter, LocalDateTime.now(), sessionId);
        connections.put(userId, connection);

        // ì—°ê²° ì¢…ë£Œ ì‹œ ì •ë¦¬
        emitter.onCompletion(() -> connections.remove(userId));
        emitter.onTimeout(() -> connections.remove(userId));
        emitter.onError((ex) -> connections.remove(userId));

        return emitter;
    }

    @Scheduled(fixedRate = 300000) // 5ë¶„ë§ˆë‹¤
    public void cleanupStaleConnections() {
        LocalDateTime cutoff = LocalDateTime.now().minusMinutes(10);

        connections.entrySet().removeIf(entry -> {
            SseConnection conn = entry.getValue();
            if (conn.getLastActivity().isBefore(cutoff)) {
                try {
                    conn.getEmitter().complete();
                } catch (Exception e) {
                    // ì´ë¯¸ ì¢…ë£Œëœ ì—°ê²°
                }
                return true;
            }
            return false;
        });
    }
}
í•µì‹¬ í¬ì¸íŠ¸

SSEëŠ” HTTP ì—°ê²°ì´ ê³„ì† ì—´ë ¤ìˆëŠ” ìƒíƒœ
ì„œë²„ì—ì„œ ì—°ê²° ëª©ë¡ì„ ê´€ë¦¬í•´ì•¼ í•¨ (ì–´ëŠ ì‚¬ìš©ìê°€ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€)
ë¹„ì •ìƒ ì¢…ë£Œëœ ì—°ê²°ì„ ì£¼ê¸°ì ìœ¼ë¡œ ì •ë¦¬í•´ì•¼ í•¨
ì—°ê²° ìƒíƒœì™€ ì‹¤ì œ ë„¤íŠ¸ì›Œí¬ ìƒíƒœê°€ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ






Redis + ë©”ì„¸ì§€ í ë°©ì‹ì„ ì¶”ì²œë°›ìŒ

redis ìì²´ì ìœ¼ë¡œë„ ë©”ì‹œì§€ë¥¼ ë°œí–‰í•˜ê³  êµ¬ë…í•  ìˆ˜ ìˆì§€ë§Œ, ì•ˆì •ì„±ì´ ë–¨ì–´ì§€ê¸° ë•Œë¬¸ì—
ì•ˆì •ì„±ì„ í™•ë³´í•˜ê³  ìˆëŠ” rabbitMQ ë“±ì„ ë³‘í–‰í•˜ëŠ” ê²ƒì´ ì „ì²´ì ì¸ ì•ˆì •ë„ê°€ ë†’ì•„ì§„ë‹¤




ë‚´ê°€ msaì—ì„œ ë°±ì—”ë“œ ì„œë¹„ìŠ¤ë¼ë¦¬ rabbitmqë¡œ ì´ë²¤íŠ¸ë¥¼ ì£¼ê³ ë°›ëŠ” ê²ƒë§Œ ê²½í—˜í•´ì„œ ê·¸ëŸ°ì§€ ì´ë¯¸ì§€ê°€ ì˜ ì•ˆ ê·¸ë ¤ì§€ë„¤

íŒ”ë¡œìš°í•œ ì´ë²¤íŠ¸ë¥¼ êµ¬ë…í•˜ëŠ” ìœ ì €ëŠ” í”„ë¡ íŠ¸ì—”ë“œì— ì ‘ì†í•˜ëŠ” ë¸Œë¼ìš°ì € í•˜ë‚˜ ë§ê³¤ ë­ê°€ ì—†ì„í…ë°, ì–´ë–¤ ì„œë¹„ìŠ¤ë¥¼ ê¸°ë°˜ìœ¼ë¡œ êµ¬ë…ì— ëŒ€í•œ ì•Œë¦¼ì„ ë°›ì„ ìˆ˜ ìˆì§€?

ì•„ ì •ë§ ì¢‹ì€ ì§ˆë¬¸ì´ì—ìš”! MSAì—ì„œ ì„œë¹„ìŠ¤ê°„ í†µì‹ ë§Œ ê²½í—˜í•´ë³´ì…¨ë‹¤ë©´ ë‹¹ì—°íˆ í—·ê°ˆë¦´ ìˆ˜ ìˆì–´ìš”.

í•µì‹¬ í¬ì¸íŠ¸: í”„ë¡ íŠ¸ì—”ë“œê°€ Redisë¥¼ ì§ì ‘ êµ¬ë…í•˜ëŠ” ê²Œ ì•„ë‹ˆë¼, ì¤‘ê°„ì— WebSocket ì„œë²„ê°€ ìˆì–´ì•¼ í•´ìš”!


ì „ì²´ ì•„í‚¤í…ì²˜
[ë¸Œë¼ìš°ì €] â†WebSocketâ†’ [Notification Service] â†Redisêµ¬ë…â†’ [Redis] â†ë°œí–‰â† [Event Publisher Service]

SSE ê¸°ë°˜ êµ¬ì¡°
[ë¸Œë¼ìš°ì €] â†SSEâ† [Notification Service] â†Redisêµ¬ë…â† [Redis] â†ë°œí–‰â† [Event Publisher]



[ì¸í”Œë£¨ì–¸ì„œê°€ ê²Œì‹œë¬¼ ì‘ì„±]
         â†“
[Content Service] --"ê²Œì‹œë¬¼ ìƒì„±ë¨"--> [Follow Service]
         â†“
[Follow Service] --"íŒ”ë¡œì›Œë“¤ì—ê²Œ ì•Œë¦¼"--> [Notification Service]
         â†“
[Notification Service] â†’ ê° íŒ”ë¡œì›Œì˜ SSE ì—°ê²° í™•ì¸
         â†“
[ì—°ê²°ëœ ë¸Œë¼ìš°ì €] â† SSEë¡œ ì‹¤ì‹œê°„ ì•Œë¦¼ ì „ì†¡




redisë„ rabbitMQì²˜ëŸ¼ config.javaë‚˜ application.ymlì— ì„¤ì •ì„ ì €ì¥í•˜ê±°ë‚˜ í•´?
ìˆë‹¤ë©´ ì˜ˆì œ ì¢€ ë³´ì—¬ì¤˜

ë„¤, Redisë„ RabbitMQì²˜ëŸ¼ ì„¤ì •ì´ í•„ìš”í•´ìš”! Spring Bootì—ì„œ Redisë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ ëª‡ ê°€ì§€ ì„¤ì •ì„ í•´ì•¼ í•©ë‹ˆë‹¤.

1. ì˜ì¡´ì„± ì¶”ê°€
build.gradle
gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-redis'
    implementation 'org.springframework.boot:spring-boot-starter-cache'

    // Lettuce ì»¤ë„¥ì…˜ í’€ (ê¶Œì¥)
    implementation 'org.apache.commons:commons-pool2'

    // JSON ì§ë ¬í™”ìš©
    implementation 'com.fasterxml.jackson.core:jackson-databind'
}

2. application.yml ì„¤ì •
ê¸°ë³¸ ì„¤ì •
yamlspring:
  redis:
    host: localhost
    port: 6379
    password: mypassword  # ë¹„ë°€ë²ˆí˜¸ê°€ ìˆëŠ” ê²½ìš°
    database: 0           # ê¸°ë³¸ DB ë²ˆí˜¸
    timeout: 2000ms       # ì—°ê²° íƒ€ì„ì•„ì›ƒ

    # Lettuce ì»¤ë„¥ì…˜ í’€ ì„¤ì • (ê¶Œì¥)
    lettuce:
      pool:
        max-active: 8     # ìµœëŒ€ í™œì„± ì—°ê²° ìˆ˜
        max-idle: 8       # ìµœëŒ€ ìœ íœ´ ì—°ê²° ìˆ˜
        min-idle: 0       # ìµœì†Œ ìœ íœ´ ì—°ê²° ìˆ˜
        max-wait: -1ms    # ì—°ê²° ëŒ€ê¸° ì‹œê°„ (-1ì€ ë¬´ì œí•œ)
      shutdown-timeout: 100ms

    # Jedis ì‚¬ìš© ì‹œ (alternative)
    # jedis:
    #   pool:
    #     max-active: 8
    #     max-idle: 8
    #     min-idle: 0
    #     max-wait: -1ms

  # ìºì‹œ ì„¤ì •
  cache:
    type: redis
    redis:
      time-to-live: 600000  # 10ë¶„ (ë°€ë¦¬ì´ˆ)
      cache-null-values: false
í™˜ê²½ë³„ ì„¤ì •
yaml# application-dev.yml
spring:
  redis:
    host: localhost
    port: 6379
    password: dev-password

# application-prod.yml
spring:
  redis:
    host: redis-cluster-endpoint
    port: 6379
    password: ${REDIS_PASSWORD}
    ssl: true

    # í´ëŸ¬ìŠ¤í„° ì„¤ì •
    cluster:
      nodes:
        - redis-node1:6379
        - redis-node2:6379
        - redis-node3:6379
      max-redirects: 3

    # ì„¼í‹°ë„¬ ì„¤ì • (ê³ ê°€ìš©ì„±)
    # sentinel:
    #   master: mymaster
    #   nodes:
    #     - sentinel1:26379
    #     - sentinel2:26379
    #     - sentinel3:26379
3. RedisConfig.java ì„¤ì •
ê¸°ë³¸ Config
java@Configuration
@EnableCaching
@EnableRedisRepositories
public class RedisConfig {

    @Value("${spring.redis.host}")
    private String redisHost;

    @Value("${spring.redis.port}")
    private int redisPort;

    @Value("${spring.redis.password:}")
    private String redisPassword;

    // Redis ì—°ê²° íŒ©í† ë¦¬
    @Bean
    public LettuceConnectionFactory redisConnectionFactory() {
        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
        config.setHostName(redisHost);
        config.setPort(redisPort);

        if (!redisPassword.isEmpty()) {
            config.setPassword(redisPassword);
        }

        // ì»¤ë„¥ì…˜ í’€ ì„¤ì •
        LettucePoolingClientConfiguration poolConfig = LettucePoolingClientConfiguration.builder()
            .poolConfig(jedisPoolConfig())
            .build();

        return new LettuceConnectionFactory(config, poolConfig);
    }

    // ì»¤ë„¥ì…˜ í’€ ì„¤ì •
    @Bean
    public GenericObjectPoolConfig<?> jedisPoolConfig() {
        GenericObjectPoolConfig<?> poolConfig = new GenericObjectPoolConfig<>();
        poolConfig.setMaxTotal(8);
        poolConfig.setMaxIdle(8);
        poolConfig.setMinIdle(0);
        poolConfig.setMaxWaitMillis(-1);
        return poolConfig;
    }

    // RedisTemplate ì„¤ì • (ì¼ë°˜ ë°ì´í„°ìš©)
    @Bean
    public RedisTemplate<String, Object> redisTemplate() {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(redisConnectionFactory());

        // JSON ì§ë ¬í™” ì„¤ì •
        Jackson2JsonRedisSerializer<Object> serializer = new Jackson2JsonRedisSerializer<>(Object.class);
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);
        serializer.setObjectMapper(objectMapper);

        // í‚¤ëŠ” String, ê°’ì€ JSONìœ¼ë¡œ ì§ë ¬í™”
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(serializer);
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(serializer);

        template.afterPropertiesSet();
        return template;
    }

    // StringRedisTemplate (ë¬¸ìì—´ ì „ìš©)
    @Bean
    public StringRedisTemplate stringRedisTemplate() {
        StringRedisTemplate template = new StringRedisTemplate();
        template.setConnectionFactory(redisConnectionFactory());
        return template;
    }
}
Pub/Sub ì „ìš© Config
java@Configuration
public class RedisPubSubConfig {

    @Autowired
    private RedisConnectionFactory connectionFactory;

    // ë©”ì‹œì§€ ë¦¬ìŠ¤ë„ˆ ì»¨í…Œì´ë„ˆ
    @Bean
    public RedisMessageListenerContainer redisMessageListenerContainer() {
        RedisMessageListenerContainer container = new RedisMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);

        // ìŠ¤ë ˆë“œ í’€ ì„¤ì •
        container.setTaskExecutor(Executors.newFixedThreadPool(10));

        return container;
    }

    // ì•Œë¦¼ ë©”ì‹œì§€ ë¦¬ìŠ¤ë„ˆ
    @Bean
    public MessageListenerAdapter notificationListener(NotificationMessageListener listener) {
        return new MessageListenerAdapter(listener, "handleMessage");
    }

    // ì±„ë„ í† í”½ ì„¤ì •
    @Bean
    public ChannelTopic notificationTopic() {
        return new ChannelTopic("notifications");
    }

    // íŒ¨í„´ í† í”½ ì„¤ì • (ì™€ì¼ë“œì¹´ë“œ êµ¬ë…)
    @Bean
    public PatternTopic userNotificationPattern() {
        return new PatternTopic("user:*:notifications");
    }
}
ìºì‹œ ì „ìš© Config
java@Configuration
@EnableCaching
public class RedisCacheConfig {

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(10))  // ê¸°ë³¸ TTL 10ë¶„
            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new Jackson2JsonRedisSerializer<>(Object.class)))
            .disableCachingNullValues();

        return RedisCacheManager.builder(connectionFactory)
            .cacheDefaults(config)
            .build();
    }

    // ìºì‹œë³„ ê°œë³„ ì„¤ì •
    @Bean
    public RedisCacheManagerBuilderCustomizer redisCacheManagerBuilderCustomizer() {
        return (builder) -> builder
            .withCacheConfiguration("users",
                RedisCacheConfiguration.defaultCacheConfig()
                    .entryTtl(Duration.ofMinutes(30)))  // ì‚¬ìš©ì ìºì‹œëŠ” 30ë¶„
            .withCacheConfiguration("notifications",
                RedisCacheConfiguration.defaultCacheConfig()
                    .entryTtl(Duration.ofMinutes(5)));   // ì•Œë¦¼ ìºì‹œëŠ” 5ë¶„
    }
}


4. ì‹¤ì œ ì‚¬ìš© ì˜ˆì‹œ
Serviceì—ì„œ RedisTemplate ì‚¬ìš©
java@Service
public class NotificationService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    // Pub/Sub ë©”ì‹œì§€ ë°œí–‰
    public void publishNotification(String userId, String message) {
        redisTemplate.convertAndSend("user:" + userId + ":notifications", message);
    }

    // ìºì‹œ ì €ì¥
    @Cacheable(value = "notifications", key = "#userId")
    public List<Notification> getNotifications(String userId) {
        return notificationRepository.findByUserId(userId);
    }

    // ì§ì ‘ Redis ì¡°ì‘
    public void saveUserSession(String sessionId, UserSession session) {
        redisTemplate.opsForValue().set("session:" + sessionId, session, Duration.ofHours(2));
    }
}
ë©”ì‹œì§€ ë¦¬ìŠ¤ë„ˆ
java@Component
public class NotificationMessageListener {

    @Autowired
    private SseEmitterService sseService;

    @RedisMessageListener(patterns = "user:*:notifications")
    public void handleMessage(String message, String channel) {
        String userId = extractUserIdFromChannel(channel);
        sseService.sendToUser(userId, message);
    }
}

5. Docker Compose ì„¤ì • (ê°œë°œìš©)
yaml# docker-compose.yml
version: '3.8'
services:
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes --requirepass mypassword
    volumes:
      - redis-data:/data
    environment:
      - REDIS_PASSWORD=mypassword

volumes:
  redis-data:





  eks í´ëŸ¬ìŠ¤í„° êµ¬ì¡°ì—ì„œ ìƒê°í•˜ë©´
  redisëŠ” rabbitMQì²˜ëŸ¼ ë³„ë„ì˜ podì—ì„œ ê´€ë¦¬
  sseëŠ” ì´ ê²½ìš° notification-service podì—ì„œ ê´€ë¦¬
  ë”°ë¼ì„œ sse ì—°ê²°ì´ ìœ ì € ì ‘ì† ì¦ê°€ë¡œ ë¶€ì¡±í•´ì§€ëŠ” ê²½ìš° notification-serviceì˜ ë ˆí”Œë¦¬ì¹´ë¥¼ ëŠ˜ë¦¬ëŠ” ë“±ì˜ í™•ì¥ì´ í•„ìš”
  ì´ë ‡ê²Œ ìƒê°í•´ë„ ë ê¹Œ?

  ì •í™•í•˜ê²Œ ì´í•´í•˜ì…¨ì–´ìš”! ğŸ‘ í•˜ì§€ë§Œ í•œ ê°€ì§€ ì¤‘ìš”í•œ ì¶”ê°€ ê³ ë ¤ì‚¬í•­ì´ ìˆìŠµë‹ˆë‹¤.

  ê¸°ë³¸ êµ¬ì¡°ëŠ” ë§ìŠµë‹ˆë‹¤
  EKS í´ëŸ¬ìŠ¤í„° êµ¬ì„±
  yaml
  # Redis Pod (StatefulSet)
  apiVersion: apps/v1
  kind: StatefulSet
  metadata:
    name: redis
  spec:
    serviceName: redis-service
    replicas: 1
    template:
      spec:
        containers:
        - name: redis
          image: redis:7-alpine
          ports:
          - containerPort: 6379

  ---
  # Notification Service Pod (Deployment)
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: notification-service
  spec:
    replicas: 3  # SSE ì—°ê²° ì¦ê°€ ì‹œ í™•ì¥
    template:
      spec:
        containers:
        - name: notification-service
          image: notification-service:latest
          ports:
          - containerPort: 8080
  âš ï¸ ì¤‘ìš”í•œ ë¬¸ì œ: Sticky Session
  ë¬¸ì œì 
  ì‚¬ìš©ìA â†’ LoadBalancer â†’ notification-service-pod-1 (SSE ì—°ê²° ìƒì„±)
                        â†“
            Redis ë©”ì‹œì§€ â†’ notification-service-pod-2 (ì—°ê²° ì •ë³´ ì—†ìŒ!)
  í•´ê²°ë°©ì•ˆ 1: Session Affinity (ê¶Œì¥)
  yaml
  # Service with Session Affinity
  apiVersion: v1
  kind: Service
  metadata:
    name: notification-service
  spec:
    selector:
      app: notification-service
    ports:
    - port: 80
      targetPort: 8080
    sessionAffinity: ClientIP  # ê°™ì€ í´ë¼ì´ì–¸íŠ¸ëŠ” ê°™ì€ Podë¡œ
    sessionAffinityConfig:
      clientIP:
        timeoutSeconds: 3600   # 1ì‹œê°„ ë™ì•ˆ ê°™ì€ Pod ìœ ì§€
  í•´ê²°ë°©ì•ˆ 2: Redis ê¸°ë°˜ SSE ì—°ê²° ê³µìœ 
  java
  @Service
  public class SharedSseConnectionManager {

      @Autowired
      private RedisTemplate<String, Object> redisTemplate;

      // ë¡œì»¬ SSE ì—°ê²° (í˜„ì¬ Podì˜ ì—°ê²°ë§Œ)
      private final Map<String, SseEmitter> localConnections = new ConcurrentHashMap<>();

      // Pod ì‹ë³„ì
      @Value("${POD_NAME:unknown}")
      private String podName;

      public SseEmitter createConnection(String userId) {
          SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);

          // ë¡œì»¬ì— ì—°ê²° ì €ì¥
          localConnections.put(userId, emitter);

          // Redisì— ì–´ëŠ Podì— ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ ì €ì¥
          redisTemplate.opsForValue().set(
              "sse:user:" + userId + ":pod",
              podName,
              Duration.ofHours(1)
          );

          emitter.onCompletion(() -> {
              localConnections.remove(userId);
              redisTemplate.delete("sse:user:" + userId + ":pod");
          });

          return emitter;
      }

      // Redis ë©”ì‹œì§€ë¥¼ ë°›ì•„ì„œ ì ì ˆí•œ Podì—ì„œë§Œ ì²˜ë¦¬
      @RedisMessageListener(patterns = "user:*:notifications")
      public void handleNotification(String message, String channel) {
          String userId = extractUserIdFromChannel(channel);

          // ì´ ì‚¬ìš©ìê°€ í˜„ì¬ Podì— ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
          String connectedPod = (String) redisTemplate.opsForValue()
              .get("sse:user:" + userId + ":pod");

          if (podName.equals(connectedPod)) {
              // í˜„ì¬ Podì— ì—°ê²°ëœ ì‚¬ìš©ìë¼ë©´ SSEë¡œ ì „ì†¡
              SseEmitter emitter = localConnections.get(userId);
              if (emitter != null) {
                  sendToEmitter(emitter, message);
              }
          }
          // ë‹¤ë¥¸ Podì— ì—°ê²°ëœ ì‚¬ìš©ìëŠ” ë¬´ì‹œ
      }
  }
  í™•ì¥ ì „ëµ
  1. HPA (Horizontal Pod Autoscaler) ì„¤ì •
  yaml
  apiVersion: autoscaling/v2
  kind: HorizontalPodAutoscaler
  metadata:
    name: notification-service-hpa
  spec:
    scaleTargetRef:
      apiVersion: apps/v1
      kind: Deployment
      name: notification-service
    minReplicas: 2
    maxReplicas: 20
    metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80
    # ì»¤ìŠ¤í…€ ë©”íŠ¸ë¦­: SSE ì—°ê²° ìˆ˜
    - type: Pods
      pods:
        metric:
          name: sse_connections_per_pod
        target:
          type: AverageValue
          averageValue: "1000"  # Podë‹¹ 1000ê°œ ì—°ê²° ê¸°ì¤€
  2. SSE ì—°ê²° ìˆ˜ ëª¨ë‹ˆí„°ë§
  java
  @Component
  public class SseMetricsCollector {

      @Autowired
      private MeterRegistry meterRegistry;

      @Autowired
      private SharedSseConnectionManager sseManager;

      @PostConstruct
      public void initMetrics() {
          // SSE ì—°ê²° ìˆ˜ ê²Œì´ì§€ ë“±ë¡
          Gauge.builder("sse.connections.active")
              .description("Active SSE connections in current pod")
              .register(meterRegistry, sseManager, SseConnectionManager::getActiveConnectionCount);
      }
  }
  3. Ingress ì„¤ì • (Sticky Session)
  yaml
  apiVersion: networking.k8s.io/v1
  kind: Ingress
  metadata:
    name: notification-ingress
    annotations:
      nginx.ingress.kubernetes.io/affinity: "cookie"
      nginx.ingress.kubernetes.io/affinity-mode: "persistent"
      nginx.ingress.kubernetes.io/session-cookie-name: "notification-session"
      nginx.ingress.kubernetes.io/session-cookie-expires: "3600"
      nginx.ingress.kubernetes.io/session-cookie-max-age: "3600"
  spec:
    rules:
    - host: notifications.example.com
      http:
        paths:
        - path: /notifications/stream
          pathType: Prefix
          backend:
            service:
              name: notification-service
              port:
                number: 80
  ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ
  Kubernetes ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§
  yaml
  # ServiceMonitor for Prometheus
  apiVersion: monitoring.coreos.com/v1
  kind: ServiceMonitor
  metadata:
    name: notification-service-monitor
  spec:
    selector:
      matchLabels:
        app: notification-service
    endpoints:
    - port: metrics
      path: /actuator/prometheus
      interval: 30s


ê²°ë¡ 
ë‹¹ì‹ ì˜ ì´í•´ê°€ ì •í™•í•©ë‹ˆë‹¤! ì¶”ê°€ë¡œ:

âœ… Redis: ë³„ë„ Pod (StatefulSet)
âœ… SSE: notification-service Podì—ì„œ ê´€ë¦¬
âœ… í™•ì¥: ë ˆí”Œë¦¬ì¹´ ì¦ê°€ë¡œ SSE ì²˜ë¦¬ ëŠ¥ë ¥ í–¥ìƒ
âš ï¸ ì£¼ì˜: Session Affinity ë˜ëŠ” Redis ê¸°ë°˜ ì—°ê²° ê³µìœ  í•„ìš”




ìµœì¢… ì™„ì„±ëœ í”Œë¡œìš°
1. ì´ë²¤íŠ¸ ë°œìƒ + íŒ”ë¡œì›Œ ì¡°íšŒ
        â†“
2. ê° íŒ”ë¡œì›Œë³„ íˆ¬íŠ¸ë™ ë°œì†¡ (RabbitMQ + Redis)
        â†“
3. Notification Service
   - RabbitMQ: DB ì €ì¥ (ëŒ€ì‹œë³´ë“œìš©)
   - Redis: SSE ì¦‰ì‹œ ì „ì†¡ (Pod í™•ì¸ + Sticky Session)
        â†“
4. ë¸Œë¼ìš°ì € ìˆ˜ì‹  (ì¬ì—°ê²° ë¡œì§ í¬í•¨)
        â†“
5. í™•ì¥ì„±: HPA + ëª¨ë‹ˆí„°ë§
ê²°ë¡ 
ë‹¹ì‹ ì˜ ì •ë¦¬ê°€ í•µì‹¬ì„ ì™„ë²½í•˜ê²Œ ì¡ì•˜ì–´ìš”! ì¶”ê°€í•œ ë¶€ë¶„ë“¤ì€:

âœ… íŒ”ë¡œì›Œ ì¡°íšŒ ê³¼ì •
âœ… ì˜¤í”„ë¼ì¸ ì‚¬ìš©ì ì²˜ë¦¬ (ì´ë¯¸ RabbitMQë¡œ í•´ê²°ë¨)
âœ… ë¸Œë¼ìš°ì € ì¬ì—°ê²° ë¡œì§
âœ… ì„±ëŠ¥ ìµœì í™” (ëŒ€ê·œëª¨ íŒ”ë¡œì›Œ)
âœ… ëª¨ë‹ˆí„°ë§ ë° ì¥ì•  ì²˜ë¦¬