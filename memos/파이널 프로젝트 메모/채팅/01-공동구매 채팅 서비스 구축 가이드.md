# 공동구매 채팅 서비스 구축 가이드

## 1. 실시간 통신 기술

### WebSocket vs Server-Sent Events (SSE)
- **WebSocket**: 양방향 실시간 통신, 채팅에 최적
- **SSE**: 서버→클라이언트 단방향, 알림용으로 적합

### Spring Boot WebSocket 구성
```java
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(new ChatWebSocketHandler(), "/chat/{roomId}")
                .setAllowedOrigins("*");
    }
}
```

## 2. 채팅방 구조 설계

### 채팅방 생성 시점
- 상품 페이지 생성 시 자동으로 채팅방 생성
- 채팅방 ID = 상품 ID로 매핑

### 채팅방 상태 관리
- **ACTIVE**: 모집 중
- **CLOSED**: 모집 완료
- **CANCELLED**: 모집 취소

### 참여자 관리
- 동적 참여/이탈 처리
- 최대 인원 제한 체크
- 모집 완료 시 미참여자 자동 제거

## 3. React 프론트엔드 구현

### WebSocket 연결 관리
```javascript
const useWebSocket = (roomId) => {
  const [socket, setSocket] = useState(null);
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    const ws = new WebSocket(`ws://localhost:8080/chat/${roomId}`);
    
    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      setMessages(prev => [...prev, message]);
    };

    setSocket(ws);
    return () => ws.close();
  }, [roomId]);

  const sendMessage = (content) => {
    if (socket && socket.readyState === WebSocket.OPEN) {
      socket.send(JSON.stringify({ content, timestamp: Date.now() }));
    }
  };

  return { messages, sendMessage };
};
```

### 채팅 컴포넌트 구조
- **ChatRoom**: 전체 채팅방 컴포넌트
- **MessageList**: 메시지 목록 표시
- **MessageInput**: 메시지 입력
- **ParticipantList**: 참여자 목록

## 4. Spring Boot 백엔드 구현

### 채팅방 엔티티 설계
```java
@Entity
public class ChatRoom {
    @Id
    private Long productId;
    
    @Enumerated(EnumType.STRING)
    private ChatRoomStatus status;
    
    private int maxParticipants;
    private LocalDateTime createdAt;
    private LocalDateTime expiresAt;
    
    @OneToMany(mappedBy = "chatRoom", cascade = CascadeType.ALL)
    private List<ChatMessage> messages;
    
    @ManyToMany
    private Set<User> participants;
}
```

### WebSocket 핸들러
```java
@Component
public class ChatWebSocketHandler extends TextWebSocketHandler {
    
    @Override
    public void afterConnectionEstablished(WebSocketSession session) {
        String roomId = extractRoomId(session);
        sessionManager.addSession(roomId, session);
    }

    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) {
        String roomId = extractRoomId(session);
        broadcastToRoom(roomId, message.getPayload());
    }
}
```

## 5. 주요 기능별 구현 전략

### 자동 채팅방 생성
- 상품 등록 시 `@EventListener` 사용하여 채팅방 자동 생성
- 비동기 처리로 성능 최적화

### 시간 기반 모집 관리
- Spring Scheduler로 만료 시간 체크
- Redis를 활용한 TTL(Time To Live) 설정

### 참여자 실시간 업데이트
- 입장/퇴장 시 전체 참여자에게 알림
- 현재 참여 인원 실시간 표시

### 메시지 타입 분류
- **CHAT**: 일반 채팅 메시지
- **SYSTEM**: 시스템 알림 (입장, 퇴장, 모집 완료 등)
- **NOTIFICATION**: 중요 공지사항

## 6. 데이터베이스 설계

### 메시지 저장 전략
- **실시간**: Redis로 임시 저장
- **영구**: MySQL/PostgreSQL로 백업
- **파일**: 대용량 파일은 별도 스토리지

### 인덱싱 전략
```sql
-- 채팅방별 메시지 조회 최적화
CREATE INDEX idx_chat_message_room_time ON chat_messages(chat_room_id, created_at);

-- 사용자별 참여 채팅방 조회
CREATE INDEX idx_participant_user_room ON chat_participants(user_id, chat_room_id);
```

## 7. 성능 최적화

### 메시지 페이징
- 최신 50개 메시지만 초기 로드
- 스크롤 업 시 과거 메시지 lazy loading

### 연결 관리
- 비활성 연결 자동 정리
- Connection Pool 최적화

### 캐싱 전략
- 활성 채팅방 정보 Redis 캐싱
- 참여자 목록 메모리 캐싱

## 8. 보안 고려사항

### 인증/인가
- JWT 토큰 기반 WebSocket 인증
- 채팅방 참여 권한 검증

### 메시지 검증
- XSS 방지를 위한 HTML 이스케이프
- 스팸 방지 rate limiting

### 개인정보 보호
- 채팅 내용 암호화 저장
- 개인 주소 정보 별도 보안 처리

## 9. 모니터링 및 로깅

### 메트릭 수집
- 동시 접속자 수
- 메시지 전송 성공/실패율
- 응답 시간

### 로깅 전략
- 채팅방 생성/삭제 이벤트
- 에러 발생 시 상세 로그
- 사용자 행동 패턴 분석

## 10. 배포 및 확장성

### 멀티 인스턴스 환경
- Redis Pub/Sub으로 서버 간 메시지 동기화
- 로드 밸런서에서 Sticky Session 설정

### 수평 확장
- 마이크로서비스 아키텍처 고려
- 채팅 서비스 독립 배포

---

핵심 포인트 요약:

1. HTTP → WebSocket 업그레이드

클라이언트가 Upgrade: websocket 헤더로 업그레이드 요청

서버가 101 Switching Protocols로 응답

이후 양방향 실시간 통신 가능


2. STOMP의 역할

WebSocket 위에서 메시징 패턴을 표준화

pub/sub 모델로 채팅방 구독/발행 쉽게 구현

/topic/chat/{roomId} 같은 destination 패턴 지원


3. 실제 구현에서의 흐름

거래 서비스 → 채팅 서비스: POST /api/chat/rooms (채팅방 생성)

클라이언트 → 채팅 서비스: WebSocket 연결 (/ws)

클라이언트 ← → 서버: STOMP 핸드셰이크

클라이언트: /topic/chat/{roomId} 구독

실시간 메시지 송수신 시작! 🚀